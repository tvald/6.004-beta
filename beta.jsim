.include "nominal.jsim"
.include "stdcell.jsim"
.include "stdalu.jsim"
.include "harness.jsim"

.subckt pc clk reset pcsel[1:0] jt[31:2] br_pc[30:2] ia[31:2] pc_annul

.connect br_pc[31] ia[31]
.connect br_pc[1:0] 0
.connect ia[1:0] 0
.connect jt[1:0] 0
.connect d[1:0] 0

Xjt31 ia[31] jt[31] _jt31 and2

Xpcsel pcsel[0]#30 pcsel[1]#30
+ br_pc[31:2]     // BR / PC4  (0b00)
+ _jt31 jt[30:2]  // JT    (0b01)
+ vdd 0#27 0 vdd  // ILLOP (0b10)
+ vdd 0#27 vdd 0  // XADDR (0b11)
+ _d[31:2] mux4
Xreset reset#30 _d[31:2] vdd 0#29 d[31:2] mux2

Xregpc d[31:2] clk#30 ia[31:2] dreg

Xannul reset pcsel[1] pcsel[0] pc_annul or3

.ends


.subckt regfile clk werf wasel ra2sel ra[4:0] rb[4:0] rc[4:0]
+ wdata[31:0] radata[31:0] rbdata[31:0]

Xwa wasel#5 rc[4:0] vdd#4 0 wa[4:0]  mux2

Xregfile
+ vdd 0 0 ra[4:0] adata[31:0] // A read port
+ vdd 0 0 ra2mux[4:0] bdata[31:0] // B read port
+ 0 clk werf wa[4:0] wdata[31:0] // write port
+ $memory width=32 nlocations=31

Xra2 ra2sel#5 rb[4:0] rc[4:0] ra2mux[4:0] mux2

Xr31a1 ra[4:3] a1 nand2
Xr31a2 ra[2:0] a2 nand3
Xr31a3 a1 a2 r31a or2   // merge nor2 with subsequent inverter

Xadata adata[31:0] r31a#32 radata[31:0] and2

Xr31b1 ra2mux[4:3] b1 nand2
Xr31b2 ra2mux[2:0] b2 nand3
Xr31b3 b1 b2 r31b or2   // merge nor2 with subsequent inverter

Xbdata bdata[31:0] r31b#32 rbdata[31:0] and2

.ends


.subckt ctl reset irq z id[31:26] pcsel[1:0] wasel asel ra2sel bsel alufn[5:0] wdsel[1:0] werf moe wr

* reset flag
Xwr reset xwr 0 wr mux2

* irq flag
Xirq irq#7
+ _werf _wdsel[1:0] _wr _pcsel[1:0] _wasel
+   vdd         0#2   0     vdd vdd    vdd
+  werf  wdsel[1:0] xwr  pcsel[1:0]  wasel
+ mux2


* RA2SEL: ST (0b011001) = 1 / OP (0b10XXXX) = 0 / OTHER = X (default to 1 for ease)
Xra0 id[30] ra0 inverter
Xra1 id[31] ra0 ra2sel nand2

* WR: ST (0b011001) = 1 / OTHER = 0
Xst0 id[31] id[28] id[27] st0 nor3
Xst1 id[30] id[29] id[26] st1 and3
Xst2 st0 st1 _wr and2

* ROM
Xctl vdd 0 0 id[31:26] // one read port
+ _pcsel[1:0] _wasel asel bsel alufn[5:0] _wdsel[1:0] _werf moe
+ $memory width=15 nlocations=64 contents=(
+ 0b101000000000010 // opcode=0b000000
+ 0b101000000000010 // opcode=0b000001
+ 0b101000000000010 // opcode=0b000010
+ 0b101000000000010 // opcode=0b000011
+ 0b101000000000010 // opcode=0b000100
+ 0b101000000000010 // opcode=0b000101
+ 0b101000000000010 // opcode=0b000110
+ 0b101000000000010 // opcode=0b000111
+ 0b101000000000010 // opcode=0b001000
+ 0b101000000000010 // opcode=0b001001
+ 0b101000000000010 // opcode=0b001010
+ 0b101000000000010 // opcode=0b001011
+ 0b101000000000010 // opcode=0b001100
+ 0b101000000000010 // opcode=0b001101
+ 0b101000000000010 // opcode=0b001110
+ 0b101000000000010 // opcode=0b001111
+ 0b101000000000010 // opcode=0b010000
+ 0b101000000000010 // opcode=0b010001
+ 0b101000000000010 // opcode=0b010010
+ 0b101000000000010 // opcode=0b010011
+ 0b101000000000010 // opcode=0b010100
+ 0b101000000000010 // opcode=0b010101
+ 0b101000000000010 // opcode=0b010110
+ 0b101000000000010 // opcode=0b010111
+ 0b000010000001011 // opcode=0b011000 LD
+ 0b000010000000000 // opcode=0b011001 ST
+ 0b101000000000010 // opcode=0b011010 
+ 0b010000000000010 // opcode=0b011011 JMP
+ 0b101000000000010 // opcode=0b011100 
+ 0b000000000000010 // opcode=0b011101 BEQ
+ 0b000000000000010 // opcode=0b011110 BNE
+ 0b000100110101011 // opcode=0b011111 LDR
+ 0b000000000000110 // opcode=0b100000 ADD
+ 0b000000000010110 // opcode=0b100001 SUB
+ 0b000000000000110 // opcode=0b100010 MUL
+ 0b000000000000110 // opcode=0b100011 DIV
+ 0b000001100110110 // opcode=0b100100 CMPEQ
+ 0b000001101010110 // opcode=0b100101 CMPLT
+ 0b000001101110110 // opcode=0b100110 CMPLE
+ 0b101000000000010 // opcode=0b100111 
+ 0b000000110000110 // opcode=0b101000 AND
+ 0b000000111100110 // opcode=0b101001 OR
+ 0b000000101100110 // opcode=0b101010 XOR
+ 0b101000000000010 // opcode=0b101011 
+ 0b000001000000110 // opcode=0b101100 SHL
+ 0b000001000010110 // opcode=0b101101 SHR
+ 0b000001000110110 // opcode=0b101110 SRA
+ 0b101000000000010 // opcode=0b101111 
+ 0b000010000000110 // opcode=0b110000 ADDC
+ 0b000010000010110 // opcode=0b110001 SUBC
+ 0b000010000000110 // opcode=0b110010 MULC
+ 0b000010000000110 // opcode=0b110011 DIVC
+ 0b000011100110110 // opcode=0b110100 CMPEQC
+ 0b000011101010110 // opcode=0b110101 CMPLTC
+ 0b000011101110110 // opcode=0b110110 CMPLEC
+ 0b101000000000010 // opcode=0b110111 
+ 0b000010110000110 // opcode=0b111000 ANDC
+ 0b000010111100110 // opcode=0b111001 ORC
+ 0b000010101100110 // opcode=0b111010 XORC
+ 0b101000000000010 // opcode=0b111011 
+ 0b000011000000110 // opcode=0b111100 SHLC
+ 0b000011000010110 // opcode=0b111101 SHRC
+ 0b000011000110110 // opcode=0b111110 SRAC
+ 0b101000000000010 // opcode=0b111111 
+ )

.ends

.subckt brtest id[31:26] br_flag
.ends


// BRANCH PREDICTION
.subckt branch_ctl clk reset ia[31:2] id[31:0] z br_pc[31:2] last_pc[31:2] last_pcr[31:2] br_annul

// branch instruction flag
Xb1 id[27:26] b1 xor2
Xb2 id[31] b2 inverter
Xb3 b1 b2 b3 nand2
Xb4 id[30:28] b4 nand3
Xb5 b3 b4 br_annul reset br_flag nor4

// increment pc + 4
Xpc4 ia[30:2] ci[29:2] vdd pc[30:2] ci[30:2] incrementer
.connect pc[31] ia[31]
.connect pc[1:0] 0

// pc branch / relative offset
Xidbuf id[15:0] _id[15:0] buffer_8
Xpcr 0#3 pc[30:2] 0#3 _id[15]#13 _id[15:0] 0 _[2:0] pcr[30:2] _[3] cs_adder32 //TODO: simplify me
//Xpcr  pc[30:2]  _id[15]#13 _id[15:0]  c[29:2] 0  pcr[30:2]  c[30:2] fulladder
.connect pcr[31] ia[31]
.connect pcr[1:0] 0

// predict whether branch taken (taken if z=1)
Xbrpred  vdd br_flag _br_pred and2	// for now, always take branch
Xbrpredbuf _br_pred br_pred buffer_8

// store values for next phase
Xregpred br_pred clk last_pred dreg	// branch prediction
Xregflag br_flag clk last_flag dreg	// was branch instruction
Xregpc   pc[31:2]  clk#30 last_pc[31:2]  dreg	// last pc increment
Xregpcr  pcr[31:2] clk#30 last_pcr[31:2] dreg	// last pc branch / relative

// annul if messed up last prediction
Xbrmiss last_pred z br_miss xor2
Xannul last_flag br_miss br_annul and2

// set next pc instruction address
Xpc_pred br_pred#30  pc[31:2]      pcr[31:2]      pred_pc[31:2] mux2
Xpc_miss z#30        last_pc[31:2] last_pcr[31:2] miss_pc[31:2] mux2
Xpc_br   br_annul#30 pred_pc[31:2] miss_pc[31:2]  br_pc[31:2]   mux2

.ends


// BETA: COMPLETE CIRCUIT
.subckt beta clk reset irq ia[31:0] id[31:0] ma[31:0] moe mrd[31:0] wr mwd[31:0]
.connect ia[1:0] ma[1:0] 0
Xirq ia[31] irq 0 _irq mux2  // supervisor bit overrides irq

// IF: INSTRUCTION FETCH
Xbeta1 clk reset z pcsel[1:0] jt[31:2] ia[31:2] id[31:0] if_pc[31:2] if_pcr[31:2] if_ir[31:0] beta_1

// IF-EXE BORDER
Xexepc  if_pc[31:2]  exe_pc[31:2]  cnxn  // registers inside stage 1
Xexepcr if_pcr[31:2] exe_pcr[31:2] cnxn  // registers inside stage 1
Xregir  if_ir[31:0]  clk#32 exe_ir[31:0]  dreg


// EXE: INSTRUCTION EXECUTION
Xbeta2 clk reset _irq exe_pc[31:2] exe_pcr[31:2] exe_ir[31:0] ma[31:2] moe mrd[31:0] wr mwd[31:0] z pcsel[1:0] jt[31:2] beta_2

.ends


// BETA STAGE 1: INSTRUCTION FETCH
.subckt beta_1 clk reset z pcsel[1:0] jt[31:2] ia[31:2] id[31:0] pc[31:2] pcr[31:2] ir[31:0]

* PC Control
Xpc clk reset pcsel[1:0] jt[31:2] br_pc[30:2] ia[31:2] pc_annul pc

* Branch Control
Xbr clk reset ia[31:2] id[31:0] z br_pc[31:2] pc[31:2] pcr[31:2] br_annul branch_ctl

* annul logic, defaulting IR[31:0] to ADD(R31,R31,R31)=0x87FFFF
Xannulchk pc_annul br_annul annul or2
Xannul annul#32 id[31:0] vdd 0#5 vdd#26  ir[31:0] mux2

.ends


// BETA STAGE 2: INSTRUCTION EXECUTION
.subckt beta_2 clk reset irq pc[31:2] pcr[31:2] ir[31:0] ma[31:2] moe mrd[31:0] wr mwd[31:0] z pcsel[1:0] jt[31:2]

* control logic
Xctl reset irq z ir[31:26] pcsel[1:0] wasel asel ra2sel bsel alufn[5:0] wdsel[1:0] werf moe wr   ctl

* registers
Xra ir[20:16] ra[4:0] cnxn
Xrb ir[15:11] rb[4:0] cnxn
Xrc ir[25:21] rc[4:0] cnxn
Xregfile clk werf wasel ra2sel ra[4:0] rb[4:0] rc[4:0] wdata[31:0] radata[31:0] rbdata[31:0]   regfile

* calculate Z (reg[A]==0)
Xznor radata[31:0] znor[7:0] nor4
Xznan znor[7:0] znan[1:0] nand4
Xzout znan[1:0] _z nor2
Xzmod _z ir[27] z xor2

* route JT
Xjt radata[31:2] jt[31:2] cnxn

* ALU input selection
Xasel asel#32 radata[31:0] 0 pcr[30:2] 0#2    a[31:0] mux2
Xbsel bsel#32 rbdata[31:0] ir[15]#16 ir[15:0] b[31:0] mux2

* ALU
Xalu alufn[5:0] a[31:0] b[31:0] alu[31:0]             alu

* write data selection
Xwdsel wdsel[0]#32 wdsel[1]#32 pc[31:2] 0#2 alu[31:0] mrd[31:0] 0#32 wdata[31:0] mux4

Xma  alu[31:2] ma[31:2] cnxn
Xmwd rbdata[31:0] mwd[31:0] cnxn

.ends
